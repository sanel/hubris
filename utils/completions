sorted-map
read-line
re-pattern
keyword?
val
chunked-seq?
*compile-path*
max-key
list*
ns-aliases
booleans
the-ns
==
chunk-buffer
longs
special-form-anchor
shorts
instance?
syntax-symbol-anchor
format
sequential?
fn?
empty
bound-fn
dorun
time
remove-method
gensym
not=
*3
unchecked-multiply
doseq
bit-or
aset-byte
if-not
hash-set
add-watch
unchecked-dec
some
nil?
string?
boolean-array
second
letfn
keys
for
*2
long-array
pop-thread-bindings
cond
bit-set
fn
sorted?
short-array
ns-unalias
ns-publics
char-array
dosync
all-ns
long
with-open
init-proxy
add-classpath
false?
await1
true?
gen-interface
sync
short
ns-unmap
repeat
zipmap
distinct
get-in
bit-xor
char-escape-string
complement
let
get-validator
dotimes
ref-max-history
print-namespace-doc
*ns*
promise
defmethod
pop!
derive
aset-float
lazy-cat
commute
defstruct
with-in-str
rem
odd?
symbol?
*print-level*
*allow-unresolved-vars*
*macro-meta*
proxy-call-with-super
ns-interns
re-matches
split-with
find-doc
loop
future-done?
next
import
deliver
symbol
vals
print-doc
select-keys
re-matcher
rand
deref
unchecked-inc
*math-context*
read
sequence
make-hierarchy
+
number?
assoc!
descendants
into-array
last
unchecked-negate
integer?
*read-eval*
alter
prn
with-meta
with-out-str
floats
*
*compile-files*
when-not
butlast
-
->>
reversible?
rseq
send-off
seq?
refer-clojure
identical?
..
print
vary-meta
with-loading-context
*command-line-args*
bit-flip
zero?
bit-and
unquote-splicing
future
re-groups
*warn-on-reflection*
newline
replicate
char?
distinct?
remove-ns
ratio?
xml-seq
vec
concat
update-in
vector
with-bindings*
conj
bases
/
unchecked-add
ref-set
assoc
seque
aset-char
boolean
read-string
neg?
float-array
doubles
isa?
future-call
doto
remove-watch
print-str
*e
ref-history-count
rsubseq
*flush-on-newline*
*out*
future?
vector?
split-at
chunk-cons
ns-refers
create-struct
proxy-super
int-array
float
assert
map
counted?
memfn
double-array
accessor
*print-length*
chars
class?
rand-int
*1
aset-short
prn-str
iterate
chunk-append
when-first
slurp
mapcat
assoc-in
get-thread-bindings
special-symbol?
ref
conj!
find-var
inc
future-cancel
definline
bound-fn*
unchecked-subtract
ns-name
defn-
*file*
re-find
bit-not
construct-proxy
ref-min-history
destructure
seq
intern
pvalues
to-array-2d
sorted-map-by
filter
*clojure-version*
var?
alter-meta!
comment
key
class
re-seq
ns
empty?
test
print-dup
create-ns
name
list?
aset
nnext
doall
macroexpand-1
not-any?
resultset-seq
into
with-precision
*use-context-classloader*
transient
ffirst
bit-clear
proxy-name
load-reader
or
hash
print-ctor
associative?
float?
drop-last
replace
decimal?
defn
parents
map?
prefers
condp
quot
chunk-rest
file-seq
send
with-local-vars
reverse
with-bindings
count
get-proxy-class
set
when-let
comp
nth
byte
dissoc!
*err*
constantly
load
namespace
pr-str
<
rationalize
sort-by
cycle
peek
reduce
interleave
amap
->
cons
macroexpand
var-set
str
aset-boolean
ns-imports
while
first
bean
=
memoize
var-get
range
tree-seq
defmacro
set-validator!
aset-double
enumeration-seq
prefer-method
ensure
find-ns
not-every?
struct-map
>
max
proxy-mappings
identity
ints
fnext
min-key
reset-meta!
push-thread-bindings
subs
compile
agent-errors
clear-agent-errors
printf
ns-resolve
method-sig
>=
stream?
shutdown-agents
reset!
even?
require
bit-shift-left
methods
future-cancelled?
compare
sorted-set-by
cast
supers
pcalls
load-string
get
<=
await
resolve
bytes
print-method
loaded-libs
force
partial
pmap
if-let
comparator
pos?
char
take-while
and
refer
underive
in-ns
iterator-seq
declare
ancestors
persistent!
locking
partition
contains?
update-proxy
interpose
chunk
aset-int
ifn?
load-file
delay
apply
swap!
defmulti
proxy
subvec
byte-array
rest
keyword
ns-map
unquote
int
release-pending-sends
mod
bigdec
nfirst
nthnext
*agent*
aset-long
struct
array-map
bigint
dec
println
aget
pr
drop
clojure-version
*print-dup*
gen-class
eval
unchecked-remainder
aclone
char-name-string
pop
primitives-classnames
atom
defonce
bit-shift-right
delay?
num
disj
io!
*print-readably*
rational?
merge-with
take-nth
*print-meta*
double
lazy-seq
*in*
take-last
line-seq
take
when
areduce
set?
make-array
alias
use
juxt
alength
chunk-first
*source-path*
to-array
hash-map
bit-and-not
compare-and-set!
*assert*
type
repeatedly
trampoline
remove
find
coll?
drop-while
not-empty
print-special-doc
println-str
list
chunk-next
every?
flush
sort
dissoc
not
binding
doc
get-method
agent
sorted-set
alter-var-root
merge
subseq
min
print-simple
bit-test
await-for
disj!
meta
unchecked-divide
rename-keys
union
select
project
join
intersection
map-invert
difference
rename
index
content-handler
*stack*
attrs
element
tag
startparse-sax
*current*
content
*state*
parse
emit-element
*sb*
emit
lefts
down
insert-left
up
next
path
children
vector-zip
append-child
zipper
branch?
end?
leftmost
edit
replace
insert-right
root
insert-child
prev
seq-zip
xml-zip
make-node
rights
node
right
left
remove
rightmost
